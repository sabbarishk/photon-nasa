# {{ title }}
# Dataset: {{ dataset_url }}
# Variable: {{ variable }}

import pandas as pd
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import urllib.request
import io
import warnings
warnings.filterwarnings('ignore')

url = "{{ dataset_url }}"
variable_name = "{{ variable }}"
title = "{{ title }}"

plt.style.use('seaborn-v0_8-darkgrid')
plt.rcParams['figure.figsize'] = (16, 5)
plt.rcParams['font.size'] = 11

# ── STEP 1: FETCH ──────────────────────────────────────────────────────────────
print(f"Loading: {url}")
try:
    req = urllib.request.Request(url, headers={"User-Agent": "Mozilla/5.0"})
    with urllib.request.urlopen(req, timeout=30) as resp:
        raw_bytes = resp.read()
except Exception as e:
    print(f"Cannot fetch URL: {e}"); raise SystemExit(1)

try:    raw_text = raw_bytes.decode("utf-8")
except: raw_text = raw_bytes.decode("latin-1")

stripped = raw_text.strip()

# Reject HTML responses (landing pages, login walls)
if stripped[:200].lower().lstrip().startswith(("<!doctype", "<html", "<!--")):
    print("ERROR: URL returned an HTML page, not data.")
    print(f"URL: {url}")
    print("Please use a direct .csv download URL, not a dataset landing page.")
    raise SystemExit(1)

# Handle JSON
if stripped.startswith("{") or stripped.startswith("["):
    import json as _j
    try:
        obj = _j.loads(stripped)
        rows = obj if isinstance(obj, list) else obj.get("data", obj.get("results", [obj]))
        _jdf = pd.DataFrame(rows)
        raw_text = _jdf.to_csv(index=False)
        print(f"JSON converted to CSV: {_jdf.shape}")
    except Exception as e:
        print(f"JSON parse failed: {e}"); raise SystemExit(1)

print(f"Fetched {len(raw_text):,} bytes")

# ── STEP 2: PARSE CSV ─────────────────────────────────────────────────────────
# Auto-detect leading comment rows
lines = raw_text.split("\n")
skiprows = 0
for i, line in enumerate(lines[:40]):
    ls = line.strip()
    if not ls or ls.startswith(("#", "%", "!", "/")):
        skiprows = i + 1
    else:
        break
if skiprows: print(f"Skipping {skiprows} comment rows")

strategies = [
    dict(sep=",",  skiprows=skiprows,     on_bad_lines="skip"),
    dict(sep="\t", skiprows=skiprows,     on_bad_lines="skip"),
    dict(sep=",",  skiprows=skiprows + 1, on_bad_lines="skip"),
    dict(sep=None, skiprows=skiprows,     on_bad_lines="skip", engine="python"),
    dict(sep=",",  skiprows=0,            on_bad_lines="skip"),
]
df = None
for i, params in enumerate(strategies):
    try:
        t = pd.read_csv(io.StringIO(raw_text), **params)
        cols = [str(c) for c in t.columns]
        if len(t) > 1 and not any("doctype" in c.lower() or "<html" in c.lower() for c in cols):
            df = t
            print(f"Parsed with strategy {i+1}: {df.shape[0]} rows x {df.shape[1]} cols")
            break
    except Exception:
        continue

if df is None:
    print(f"All CSV strategies failed. Sample:\n{raw_text[:300]}"); raise SystemExit(1)

# Clean column names
df.columns = [str(c).strip().replace("\r","").replace("\ufeff","") for c in df.columns]

# GISS-style: detect when first data row actually contains headers
if len(df) > 1:
    first = df.iloc[0].astype(str).tolist()
    if all(v.replace(".","").replace("-","").replace("*","").isalpha()
           for v in first[:min(5, len(first))] if v not in ("nan","","None")):
        df.columns = [v.strip() for v in first]
        df = df.iloc[1:].reset_index(drop=True)
        print(f"GISS headers extracted: {list(df.columns[:8])}")

# Convert to numeric
for col in df.columns:
    df[col] = pd.to_numeric(df[col].astype(str).str.strip().str.replace("***","",regex=False), errors="ignore")

print(f"Shape: {df.shape} | Columns: {list(df.columns[:10])}")

#  STEP 3: FIND VARIABLE COLUMN 
numeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()
target_col = None

if variable_name in df.columns:
    target_col = variable_name
else:
    vl = variable_name.lower()
    for col in df.columns:
        if vl in str(col).lower() or str(col).lower() in vl:
            target_col = col; break

if target_col is None and numeric_cols:
    target_col = numeric_cols[0]
    print(f"Variable '{variable_name}' not found - using first numeric: '{target_col}'")
    print(f"Available columns: {list(df.columns)}")

if target_col is None:
    print(f"No numeric columns. Columns: {list(df.columns)}"); raise SystemExit(1)

print(f"Target column: {target_col}")

#  STEP 4: FIND TIME / X AXIS 
time_col = None
for tc in ["year","date","time","month","day","timestamp","yr"]:
    for col in df.columns:
        if tc in str(col).lower(): time_col = col; break
    if time_col: break
if time_col is None:
    for col in numeric_cols:
        if col != target_col: time_col = col; break
if time_col is None:
    df["_index"] = range(len(df)); time_col = "_index"

plot_df = df[[time_col, target_col]].copy()
plot_df[time_col]   = pd.to_numeric(plot_df[time_col],   errors="coerce")
plot_df[target_col] = pd.to_numeric(plot_df[target_col], errors="coerce")
plot_df = plot_df.dropna()

if len(plot_df) == 0:
    print("No valid numeric rows after cleaning."); raise SystemExit(1)

x = plot_df[time_col].values
y = plot_df[target_col].values
print(f"Points: {len(y)} | min={y.min():.4f} max={y.max():.4f} mean={y.mean():.4f}")

#  STEP 5: VISUALIZE 
fig, axes = plt.subplots(1, 3, figsize=(16, 5))
fig.suptitle(title, fontsize=14, fontweight="bold", y=1.02)

# Plot 1: Time series + trend line
axes[0].plot(x, y, color="#2E86AB", linewidth=1.5, alpha=0.85)
if len(x) >= 3:
    try:
        z = np.polyfit(x, y, 1); p = np.poly1d(z)
        axes[0].plot(x, p(x), "r--", linewidth=1.5, label=f"trend: {z[0]:+.4f}/unit")
        axes[0].legend(fontsize=8)
    except Exception: pass
axes[0].set_title(f"{target_col} over {time_col}")
axes[0].set_xlabel(time_col); axes[0].set_ylabel(target_col)

# Plot 2: Histogram
axes[1].hist(y, bins=min(30, max(10, len(y)//10)), color="#A23B72", alpha=0.75, edgecolor="white")
axes[1].axvline(np.mean(y), color="red", linestyle="--", linewidth=1.5, label=f"mean={np.mean(y):.3f}")
axes[1].set_title(f"Distribution of {target_col}")
axes[1].set_xlabel(target_col); axes[1].set_ylabel("Count"); axes[1].legend(fontsize=8)

# Plot 3: Rolling mean
window = max(3, len(y)//15)
roll = pd.Series(y).rolling(window=window, center=True).mean()
axes[2].plot(x, y, color="#2E86AB", linewidth=0.8, alpha=0.35, label="raw")
axes[2].plot(x, roll, color="#F18F01", linewidth=2, label=f"{window}-pt mean")
axes[2].set_title(f"Smoothed {target_col}")
axes[2].set_xlabel(time_col); axes[2].set_ylabel(target_col); axes[2].legend(fontsize=8)

plt.tight_layout()
plt.show()
print("Plot generated")
print(f"Points: {len(y)} | Mean: {np.mean(y):.4f} | Range: [{y.min():.4f}, {y.max():.4f}]")